export declare const SHADER_CODE = "\nstruct Uniforms {\n  resolution: vec2f,\n  rectPos: vec2f,\n  rectSize: vec2f,\n  time: f32,\n  refraction: f32,\n  bevelDepth: f32,\n  bevelWidth: f32,\n  radius: f32,\n  textureWidth: f32,\n  textureHeight: f32,\n}\n\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var bgTexture: texture_2d<f32>;\n@group(0) @binding(2) var bgSampler: sampler;\n\nstruct VertexOutput {\n  @builtin(position) position: vec4f,\n  @location(0) uv: vec2f,\n}\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n  var positions = array<vec2f, 6>(\n    vec2f(-1.0, -1.0),\n    vec2f(1.0, -1.0),\n    vec2f(-1.0, 1.0),\n    vec2f(-1.0, 1.0),\n    vec2f(1.0, -1.0),\n    vec2f(1.0, 1.0)\n  );\n  \n  var output: VertexOutput;\n  output.position = vec4f(positions[vertexIndex], 0.0, 1.0);\n  output.uv = (positions[vertexIndex] + 1.0) * 0.5;\n  return output;\n}\n\n// Unsigned distance to rounded box\nfn udRoundBox(p: vec2f, b: vec2f, r: f32) -> f32 {\n  return length(max(abs(p) - b + r, vec2f(0.0))) - r;\n}\n\nfn random(st: vec2f) -> f32 {\n  return fract(sin(dot(st, vec2f(12.9898, 78.233))) * 43758.5453123);\n}\n\nfn edgeFactor(uv: vec2f, rectSize: vec2f, radius: f32) -> f32 {\n  let p_px = (uv - 0.5) * rectSize;\n  let b_px = 0.5 * rectSize;\n  let d = -udRoundBox(p_px, b_px, radius);\n  let bevel_px = uniforms.bevelWidth * min(rectSize.x, rectSize.y);\n  return 1.0 - smoothstep(0.0, bevel_px, d);\n}\n\n@fragment\nfn fs_main(input: VertexOutput) -> @location(0) vec4f {\n  // input.uv is already 0-1 within the canvas (which fills the rectangle)\n  let localUV = input.uv;\n  \n  // Calculate edge factor for beveling\n  let edge = edgeFactor(localUV, uniforms.rectSize, uniforms.radius);\n  \n  // Calculate refraction offset\n  let p = localUV - 0.5;\n  \n  // Create rectangular distortion area that maintains aspect ratio\n  // Keep small safe space from borders (distortion area is 0.85 of the size)\n  let distortionScale = vec2f(1, 1); // Small safe space around borders\n  let normalizedP = p / distortionScale; // Scale to -1 to 1 in distortion area\n  \n  // Calculate distance for rectangular distortion using max of abs values\n  let rectDist = max(abs(normalizedP.x), abs(normalizedP.y));\n  let centerDistortion = smoothstep(1.0, 0.0, rectDist); // Stronger inside rectangle\n  \n  // Use rectangular distance instead of circular for blend to avoid ball shape\n  let rectBlend = smoothstep(0.15, 0.45, rectDist);\n  \n  let offsetAmt = (edge * uniforms.refraction + pow(edge, 10.0) * uniforms.bevelDepth) * (1.0 + centerDistortion * 3.0);\n  let offset = normalize(p) * offsetAmt * rectBlend;\n  \n  // Map to the correct part of the captured background texture\n  // Convert rectangle position to normalized texture coordinates\n  let texLeft = uniforms.rectPos.x / uniforms.textureWidth;\n  let texTop = uniforms.rectPos.y / uniforms.textureHeight;\n  let texWidth = uniforms.rectSize.x / uniforms.textureWidth;\n  let texHeight = uniforms.rectSize.y / uniforms.textureHeight;\n  \n  // Sample from the correct region with refraction\n  // Flip Y coordinate since texture origin is top-left, but we want natural orientation\n  let flippedUV = vec2f(localUV.x, 1.0 - localUV.y);\n  let bgUV = vec2f(texLeft, texTop) + flippedUV * vec2f(texWidth, texHeight) + offset * vec2f(1.0, -1.0) * 0.1;\n  \n  var refrCol: vec4f;\n  \n  // Chromatic aberration strength increases at edges, fade out in center\n  let chromaticStrength = edge * 0.003;\n  let centerFade = smoothstep(0.0, 0.4, rectDist); // Fade chromatic effect in center\n  \n\n  // Chromatic aberration - sample RGB channels separately with slight offset at edges\n  let offsetDir = normalize(p);\n  \n  // Apply chromatic aberration only at edges/sides\n  let chromaticOffset = chromaticStrength * centerFade;\n  \n  // Red channel - shifted outward\n  let rUV = bgUV + offsetDir * chromaticOffset * 1.5;\n  let r = textureSample(bgTexture, bgSampler, rUV).r;\n  \n  // Green channel - center\n  let g = textureSample(bgTexture, bgSampler, bgUV).g;\n  \n  // Blue channel - shifted inward\n  let bUV = bgUV - offsetDir * chromaticOffset;\n  let b = textureSample(bgTexture, bgSampler, bUV).b;\n  \n  refrCol = vec4f(r, g, b, 1.0);\n\n  // Apply shape mask with rounded corners\n  let p_px = (localUV - 0.5) * uniforms.rectSize;\n  let b_px = 0.5 * uniforms.rectSize;\n  let dmask = udRoundBox(p_px, b_px, uniforms.radius);\n  let inShape = 1.0 - step(0.0, dmask);\n  \n  refrCol = vec4f(refrCol.rgb * inShape, inShape * 0.9);\n  \n  return refrCol;\n}\n";
export declare const SHADER_PARAMS: {
    refraction: number;
    bevelDepth: number;
    bevelWidth: number;
    radius: number;
};
